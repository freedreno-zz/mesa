/*
 * Copyright Â© 2016 Red Hat
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef RSQ_CONTEXT_H
#define RSQ_CONTEXT_H

#include "pipe/p_context.h"
#include "util/u_slab.h"

#include "rsq_screen.h"
#include "rsq_state.h"

struct rsq_context {
   struct pipe_context base;

   struct rsq_screen *screen;

   struct pipe_context *drv;      /* wrapped driver ctx */

   unsigned surf_cnt;

   /* has a resource been cloned since last emit?  Skip dirty-due-to-clone
    * checking otherwise:
    */
   bool dirty_clone;

   /* state handled by autogenerated code: */
   struct rsq_state state;

   /* state we have to handle manually: */
   unsigned short dirty_sampler_view_shader;
   unsigned short valid_sampler_view_shader;
   unsigned dirty_sampler_view[PIPE_SHADER_TYPES];
   unsigned valid_sampler_view[PIPE_SHADER_TYPES];
   struct pipe_sampler_view *sampler_view[PIPE_SHADER_TYPES][PIPE_MAX_SAMPLERS];

   struct pipe_stream_output_target *so_targets[PIPE_MAX_SO_BUFFERS];
   unsigned so_offsets[PIPE_MAX_SO_BUFFERS];
   unsigned nr_so_targets;

   /* the current batch: */
   struct rsq_batch *batch;

   /* slab for batch-chunk allocations: */
   struct util_slab_mempool slab;
};

static inline struct rsq_context * rsq_context(struct pipe_context *pctx)
{
   return (struct rsq_context *)pctx;
}

void rsq_context_emit(struct pipe_context *pctx);
void rsq_context_replay(struct rsq_batch *batch, enum rsq_state_id id);
void rsq_context_update_batch(struct pipe_context *pctx,
                              const struct pipe_framebuffer_state *pfb);

struct pipe_context * rsq_context_create(struct pipe_screen *screen,
                                         void *priv, unsigned flags);

#define CTX_INIT(_member) \
   pctx->_member = ctx->drv->_member ? rsq_##_member : NULL

#endif /* RSQ_CONTEXT_H */
